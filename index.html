<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>æœ¬åœ°ç”µå­ä¹¦é˜…è¯»å™¨</title>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/epubjs/dist/epub.min.js"></script>
        <style>
            html,
            body {
                margin: 0;
                padding: 0;
                height: 100%;
                overflow: hidden; /* ç¦æ­¢ body å‡ºç°æ»šåŠ¨æ¡ */
            }

            body {
                font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
                margin: 0;
                /* padding: 20px; */
                background-color: #f5f5f5;
                color: #333;
            }
            .container {
                display: flex;
                flex-direction: column;
                height: 100vh; /* é«˜åº¦ä¸ºè§†å£é«˜åº¦ */
                box-sizing: border-box;
            }

            h1 {
                text-align: center;
                color: #2c3e50;
                margin-bottom: 30px;
            }
            .controls {
                display: flex;
                flex-wrap: wrap;
                gap: 10px;
                margin-bottom: 20px;
                align-items: center;
                padding: 15px;
                background-color: #f0f0f0;
                border-radius: 5px;
                flex-shrink: 0;
            }
            .control-group {
                display: flex;
                align-items: center;
                gap: 8px;
            }
            label {
                font-weight: bold;
                margin-right: 5px;
            }
            button,
            select,
            input[type="file"] {
                padding: 8px 12px;
                border: 1px solid #ddd;
                border-radius: 4px;
                background-color: white;
                font-size: 14px;
            }
            button {
                background-color: #3498db;
                color: white;
                border: none;
                cursor: pointer;
                transition: background-color 0.3s;
            }
            button:hover {
                background-color: #2980b9;
            }
            button:disabled {
                background-color: #95a5a6;
                cursor: not-allowed;
            }

            #reader {
                flex: 1;
                overflow: hidden; /* ç¦æ­¢æ¨ªå‘æ»šåŠ¨ï¼Œä¿ç•™å‚ç›´æ»šåŠ¨ç”±å†…éƒ¨æ§åˆ¶ */
                display: flex;
                border: 1px solid #ddd;
                border-radius: 5px;
                background-color: white;
                min-width: 0; /* é˜²æ­¢å­å…ƒç´ æ’‘å®½ */
            }

            #toc {
                width: 250px;
                overflow-y: auto;
                overflow-x: hidden;
                box-sizing: border-box;
                min-width: 0;
            }

            #toc-list li {
                padding: 6px 8px;
                cursor: pointer;
                user-select: none;
                font-size: 14px;
                overflow: hidden;
                white-space: nowrap;
                text-overflow: ellipsis;
            }

            #toc-list li.active {
                background-color: #3498db;
                color: white;
                font-weight: bold;
                border-radius: 4px;
            }

            #epub-viewer {
                width: 100%;
                height: 100%;
                overflow-y: auto;
                overflow-x: hidden; /* ç¦æ­¢æ¨ªå‘æ»šåŠ¨æ¡ */
                box-sizing: border-box;
            }
            #epub-viewer .epub-view {
                width: 100% !important;
            }

            .status {
                margin-top: 10px;
                margin-bottom: 10px;
                padding: 10px;
                border-radius: 4px;
                display: none;
            }
            .status.success {
                background-color: #d4edda;
                color: #155724;
                display: block;
            }
            .status.error {
                background-color: #f8d7da;
                color: #721c24;
                display: block;
            }
            .settings {
                flex-shrink: 0;
                padding: 15px;
                background-color: #f8f9fa;
                border-radius: 5px;
            }
            .settings h3 {
                margin: 5px 0;
            }
            .settings-row {
                display: flex;
                align-items: center;
                margin-right: 50px;
            }
            .settings-row:last-child {
                margin-right: 0;
            }
            .settings-row label {
                width: auto;
            }
            input[type="range"] {
                width: 200px;
                margin-right: 10px;
            }
            .font-preview {
                font-size: 1.2em;
                margin-top: 5px;
            }
            #speechControls {
                margin-top: 10px;
                padding: 10px;
                background-color: #fafafa;
                border: 1px solid #ddd;
                border-radius: 5px;
            }
            .highlight {
                background-color: yellow !important;
                color: black !important;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <h1 style="display: none">æœ¬åœ°ç”µå­ä¹¦é˜…è¯»å™¨</h1>

            <div class="controls">
                <div class="control-group">
                    <label for="bookInput">é€‰æ‹©å›¾ä¹¦:</label>
                    <input type="file" id="bookInput" accept=".txt,.epub" />
                </div>
                <div class="control-group">
                    <button id="loadFontsBtn">åŠ è½½ç³»ç»Ÿå­—ä½“</button>
                    <select id="fontSelector" disabled>
                        <option value="">-- é€‰æ‹©å­—ä½“ --</option>
                    </select>
                </div>
                <div class="control-group">
                    <button id="resetBtn">é‡ç½®æ ·å¼</button>
                </div>
            </div>

            <div class="controls" id="speechControls">
                <div class="control-group">
                    <button id="readBtn">ğŸ”Š å¼€å§‹æœ—è¯»</button>
                    <button id="pauseBtn">â¸ æš‚åœ</button>
                    <button id="resumeBtn">â–¶ï¸ ç»§ç»­</button>
                    <button id="stopBtn">â¹ åœæ­¢</button>
                </div>
                <div class="control-group">
                    <label for="voiceSelect">è¯­éŸ³:</label>
                    <select id="voiceSelect"></select>
                </div>
                <div class="control-group">
                    <label for="rateRange">è¯­é€Ÿ:</label>
                    <input
                        type="range"
                        id="rateRange"
                        min="0.5"
                        max="2"
                        step="0.1"
                        value="1"
                    />
                </div>
                <div class="control-group">
                    <label for="autoNextChapter">è‡ªåŠ¨æœ—è¯»ä¸‹ä¸€ç« :</label>
                    <input type="checkbox" id="autoNextChapter" checked />
                </div>
            </div>

            <div class="settings">
                <h3>é˜…è¯»è®¾ç½®</h3>
                <div style="display: flex">
                    <div class="settings-row">
                        <label for="fontSize">å­—ä½“å¤§å°:</label>
                        <input
                            type="range"
                            id="fontSize"
                            min="12"
                            max="32"
                            value="16"
                            step="1"
                        />
                        <span id="fontSizeValue">16px</span>
                    </div>
                    <div class="settings-row">
                        <label for="lineHeight">è¡Œé«˜:</label>
                        <input
                            type="range"
                            id="lineHeight"
                            min="1"
                            max="2.5"
                            value="1.6"
                            step="0.1"
                        />
                        <span id="lineHeightValue">1.6</span>
                    </div>
                    <div class="settings-row">
                        <label for="theme">ä¸»é¢˜:</label>
                        <select id="theme">
                            <option value="light">æµ…è‰²</option>
                            <option value="dark">æ·±è‰²</option>
                            <option value="sepia">æŠ¤çœ¼</option>
                        </select>
                    </div>
                    <div class="settings-row" style="display: none">
                        <label>å½“å‰å­—ä½“:</label>
                        <div id="currentFont" class="font-preview">
                            æœªé€‰æ‹©å­—ä½“
                        </div>
                    </div>
                </div>
            </div>

            <div id="status" class="status"></div>

            <div
                id="reader"
                style="
                    display: flex;
                    height: 70vh;
                    border: 1px solid #ddd;
                    border-radius: 5px;
                    overflow: hidden;
                "
            >
                <p
                    style="
                        text-align: center;
                        color: #777;
                        margin-top: 50px;
                        display: flex;
                        align-items: center;
                        flex: 1;
                        flex-direction: column;
                    "
                >
                    è¯·é€‰æ‹©æœ¬åœ°å›¾ä¹¦æ–‡ä»¶å¼€å§‹é˜…è¯»<br />æ”¯æŒæ ¼å¼: .txt, .epub
                </p>
            </div>
        </div>

        <script>
            const bookInput = document.getElementById("bookInput");
            const loadFontsBtn = document.getElementById("loadFontsBtn");
            const fontSelector = document.getElementById("fontSelector");
            const reader = document.getElementById("reader");
            const statusDiv = document.getElementById("status");
            const resetBtn = document.getElementById("resetBtn");
            const fontSizeSlider = document.getElementById("fontSize");
            const fontSizeValue = document.getElementById("fontSizeValue");
            const lineHeightSlider = document.getElementById("lineHeight");
            const lineHeightValue = document.getElementById("lineHeightValue");
            const themeSelect = document.getElementById("theme");
            const currentFontDisplay = document.getElementById("currentFont");

            const state = {
                currentFont: null,
                fontSize: 16,
                lineHeight: 1.6,
                theme: "light",
                isEpub: false, // æ˜¯å¦å½“å‰åœ¨é˜…è¯» epub
                isSpeaking: false, // æ˜¯å¦æ­£åœ¨æœ—è¯»
                currentSentence: null, // å½“å‰æœ—è¯»çš„å¥å­
                autoNextChapter: true, // è‡ªåŠ¨æœ—è¯»ä¸‹ä¸€ç« 
            };

            let rendition = null;
            let book = null;
            // ç¡®ä¿ä½¿ç”¨å…¨å±€çš„ speechSynthesis å¯¹è±¡
            const mySpeechSynthesis = window.speechSynthesis;
            let speechUtterance = null;
            let currentChapterText = ""; // å½“å‰ç« èŠ‚æ–‡æœ¬
            let sentences = []; // åˆ†å‰²åçš„å¥å­æ•°ç»„
            let currentSentenceIndex = 0; // å½“å‰æœ—è¯»çš„å¥å­ç´¢å¼•

            function init() {
                bookInput.addEventListener("change", handleFileSelect);
                loadFontsBtn.addEventListener("click", loadSystemFonts);
                fontSelector.addEventListener("change", applySelectedFont);
                resetBtn.addEventListener("click", resetStyles);
                fontSizeSlider.addEventListener("input", updateFontSize);
                lineHeightSlider.addEventListener("input", updateLineHeight);
                themeSelect.addEventListener("change", updateTheme);

                // æ£€æŸ¥è¯­éŸ³åˆæˆAPIæ˜¯å¦å¯ç”¨
                if ('speechSynthesis' in window) {
                    console.log("è¯­éŸ³åˆæˆAPIå¯ç”¨");
                    // åˆå§‹åŒ–è¯­éŸ³åˆæˆç›¸å…³äº‹ä»¶
                    initSpeechSynthesis();
                    
                    // ç»‘å®šæœ—è¯»æŒ‰é’®äº‹ä»¶
                    document.getElementById("readBtn").addEventListener("click", function() {
                        console.log("å¼€å§‹æœ—è¯»æŒ‰é’®è¢«ç‚¹å‡»");
                        startReading();
                    });
                    document.getElementById("pauseBtn").addEventListener("click", pauseReading);
                    document.getElementById("resumeBtn").addEventListener("click", resumeReading);
                    document.getElementById("stopBtn").addEventListener("click", stopReading);
                    
                    // è¯­é€Ÿè°ƒæ•´
                    document.getElementById("rateRange").addEventListener("input", updateSpeechRate);
                } else {
                    console.error("è¯­éŸ³åˆæˆAPIä¸å¯ç”¨");
                    showStatus("æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³åˆæˆåŠŸèƒ½", "error");
                    // ç¦ç”¨æœ—è¯»æŒ‰é’®
                    document.getElementById("readBtn").disabled = true;
                    document.getElementById("pauseBtn").disabled = true;
                    document.getElementById("resumeBtn").disabled = true;
                    document.getElementById("stopBtn").disabled = true;
                }
                
                // è‡ªåŠ¨æœ—è¯»ä¸‹ä¸€ç« æ§åˆ¶
                document.getElementById("autoNextChapter").addEventListener("change", function(e) {
                    state.autoNextChapter = e.target.checked;
                });

                updateFontSize();
                updateLineHeight();
                updateTheme();
            }

            async function handleFileSelect(event) {
                const file = event.target.files[0];
                if (!file) return;
                clearStatus();

                try {
                    if (file.name.endsWith(".txt")) {
                        state.isEpub = false;
                        if (rendition) {
                            rendition.destroy();
                            rendition = null;
                        }
                        book = null;

                        const text = await file.text();
                        displayTextContent(text);
                        showStatus(`æˆåŠŸåŠ è½½: ${file.name}`, "success");
                    } else if (file.name.endsWith(".epub")) {
                        state.isEpub = true;
                        displayEpubContent(file);
                        showStatus(`æˆåŠŸåŠ è½½: ${file.name}`, "success");
                    } else {
                        showStatus("ä¸æ”¯æŒçš„æ–‡ä»¶æ ¼å¼", "error");
                    }
                } catch (error) {
                    showStatus(`è¯»å–å¤±è´¥: ${error.message}`, "error");
                    console.error("è¯»å–é”™è¯¯ï¼š", error);
                }
            }

            function displayTextContent(text) {
                console.log("æ˜¾ç¤ºæ–‡æœ¬å†…å®¹ï¼Œæ–‡æœ¬é•¿åº¦:", text.length);
                
                // å°†æ–‡æœ¬åˆ†å‰²æˆå¥å­ï¼Œç”¨äºæœ—è¯»å’Œé«˜äº®
                currentChapterText = text;
                sentences = splitTextIntoSentences(text);
                currentSentenceIndex = 0;
                
                console.log("å‡†å¤‡æ¸²æŸ“å¥å­åˆ°HTMLï¼Œå¥å­æ•°é‡:", sentences.length);
                
                // ä¸ºæ¯ä¸ªå¥å­æ·»åŠ spanæ ‡ç­¾ï¼Œä»¥ä¾¿é«˜äº®
                let htmlContent = "";
                try {
                    sentences.forEach((sentence, index) => {
                        // å®‰å…¨å¤„ç†HTMLç‰¹æ®Šå­—ç¬¦
                        const safeText = sentence
                            .replace(/&/g, "&amp;")
                            .replace(/</g, "&lt;")
                            .replace(/>/g, "&gt;")
                            .replace(/"/g, "&quot;")
                            .replace(/'/g, "&#039;")
                            .replace(/\n/g, "<br>")
                            .replace(/ /g, "&nbsp;");
                            
                        htmlContent += `<span class="sentence" data-index="${index}">${safeText}</span>`;
                    });
                    
                    reader.innerHTML = `<div class="content">${htmlContent}</div>`;
                    console.log("æ–‡æœ¬å†…å®¹æ¸²æŸ“å®Œæˆ");
                    
                    // æ£€æŸ¥æ˜¯å¦æˆåŠŸåˆ›å»ºäº†å¥å­å…ƒç´ 
                    const sentenceElements = document.querySelectorAll(".sentence");
                    console.log("åˆ›å»ºçš„å¥å­å…ƒç´ æ•°é‡:", sentenceElements.length);
                    
                    applyCurrentSettings();
                } catch (error) {
                    console.error("æ¸²æŸ“æ–‡æœ¬å†…å®¹æ—¶å‡ºé”™:", error);
                    reader.innerHTML = `<div class="content"><p>æ¸²æŸ“æ–‡æœ¬æ—¶å‡ºé”™: ${error.message}</p></div>`;
                    showStatus("æ¸²æŸ“æ–‡æœ¬æ—¶å‡ºé”™: " + error.message, "error");
                }
            }

            function displayEpubContent(file) {
                reader.innerHTML = `
                    <div id="toc" style="width: 250px; overflow-y: auto; border-right: 1px solid #ddd; padding: 10px; box-sizing: border-box;"></div>
                    <div id="epub-viewer" style="flex: 1; overflow-x: auto; height: 100%;"></div>
                `;

                if (rendition) {
                    rendition.destroy();
                    rendition = null;
                }
                book = ePub();

                const readerInstance = new FileReader();

                readerInstance.onload = async function () {
                    try {
                        const arrayBuffer = readerInstance.result;
                        await book.open(arrayBuffer, "binary");

                        rendition = book.renderTo("epub-viewer", {
                            width: "100%",
                            height: "100%",
                            flow: "scrolled",
                            spread: "none",
                            allowScriptedContent: true,
                        });

                        window.rendition = rendition;

                        const start =
                            book.navigation?.toc?.[0]?.href || undefined;

                        await rendition.display(start);

                        generateToc(book.navigation.toc);

                        applyEpubTheme();

                        setupKeyboardListener();

                        renderToc(book.navigation.toc || []);

                        // ç»‘å®šç« èŠ‚å˜æ›´äº‹ä»¶ï¼ŒåŠ¨æ€é«˜äº®ç›®å½•
                        rendition.on("relocated", (location) => {
                            const currentHref = location.start.href.replace(
                                /#.*/,
                                ""
                            );

                            const tocItems =
                                document.querySelectorAll("#toc-list li");
                            tocItems.forEach((li) => {
                                const href = li.dataset.href?.replace(
                                    /#.*/,
                                    ""
                                );
                                if (href === currentHref) {
                                    li.classList.add("active");
                                    li.scrollIntoView({
                                        behavior: "smooth",
                                        block: "center",
                                    });
                                } else {
                                    li.classList.remove("active");
                                }
                            });
                        });

                        // æ¸…ç†æ—§äº‹ä»¶ï¼Œé¿å…å¤šæ¬¡ç»‘å®š
                        document.removeEventListener("keydown", onKeyDown);
                        document.addEventListener("keydown", onKeyDown);

                        // æ·»åŠ ç‚¹å‡»å·¦å³åŒºåŸŸç¿»é¡µæ”¯æŒ
                        const epubViewer =
                            document.getElementById("epub-viewer");
                        epubViewer.onclick = (e) => {
                            const rect = epubViewer.getBoundingClientRect();
                            const clickX = e.clientX - rect.left;
                            if (clickX < rect.width * 0.3) {
                                // å·¦è¾¹30%ç‚¹å‡» ç¿»ä¸Šä¸€é¡µ
                                rendition.prev();
                            } else if (clickX > rect.width * 0.7) {
                                // å³è¾¹30%ç‚¹å‡» ç¿»ä¸‹ä¸€é¡µ
                                rendition.next();
                            }
                        };

                        showStatus(
                            "EPUB åŠ è½½æˆåŠŸï¼Œä½¿ç”¨ â† â†’ é”®æˆ–ç‚¹å‡»å·¦å³ç¿»é¡µ",
                            "success"
                        );
                    } catch (error) {
                        console.error("EPUB åŠ è½½å¤±è´¥ï¼š", error);
                        showStatus("EPUB åŠ è½½å¤±è´¥ï¼š" + error.message, "error");
                    }
                };

                readerInstance.readAsArrayBuffer(file);
            }

            // ç”Ÿæˆç›®å½•æ ‘
            function generateToc(toc) {
                const tocDiv = document.getElementById("toc");
                if (!tocDiv || !toc) return;

                tocDiv.innerHTML = ""; // æ¸…ç©ºæ—§ç›®å½•

                const ul = document.createElement("ul");
                ul.id = "toc-list";
                ul.style.listStyle = "none";
                ul.style.paddingLeft = "0";

                function addItems(items, parentUl) {
                    items.forEach((item) => {
                        const li = document.createElement("li");
                        li.style.marginBottom = "6px";

                        const a = document.createElement("a");
                        a.href = "javascript:void(0)";
                        a.textContent = item.label;
                        a.style.color = "inherit";
                        a.style.textDecoration = "none";
                        a.style.cursor = "pointer";

                        a.onclick = () => {
                            if (rendition) {
                                rendition.display(item.href);
                            }
                        };

                        li.appendChild(a);

                        if (item.subitems && item.subitems.length > 0) {
                            const subUl = document.createElement("ul");
                            subUl.style.listStyle = "none";
                            subUl.style.paddingLeft = "15px";
                            addItems(item.subitems, subUl);
                            li.appendChild(subUl);
                        }

                        parentUl.appendChild(li);
                    });
                }

                addItems(toc, ul);
                tocDiv.appendChild(ul);
            }

            function renderToc(toc) {
                const tocList = document.getElementById("toc-list");
                tocList.innerHTML = "";

                toc.forEach((item, index) => {
                    const li = document.createElement("li");
                    li.textContent =
                        item.label || item.text || `ç« èŠ‚ ${index + 1}`;
                    li.dataset.href = item.href.split("#")[0];
                    li.style.padding = "6px 8px";
                    li.style.cursor = "pointer";
                    li.style.userSelect = "none";
                    li.title = item.label;

                    li.addEventListener("click", () => {
                        // é«˜äº®å½“å‰ç‚¹å‡»é¡¹
                        document
                            .querySelectorAll("#toc-list li")
                            .forEach((el) => {
                                el.classList.remove("active");
                            });
                        li.classList.add("active");

                        // è·³è½¬ç« èŠ‚
                        if (rendition && item.href) {
                            rendition.display(item.href);
                            // è·³è½¬ç« èŠ‚æ—¶æ»šåŠ¨å³ä¾§å®¹å™¨åˆ°é¡¶éƒ¨
                            const epubViewer =
                                document.getElementById("epub-viewer");
                            if (epubViewer) epubViewer.scrollTop = 0;
                        }
                    });

                    tocList.appendChild(li);
                });
            }

            function setupKeyboardListener() {
                // ç»™å¤–å±‚ç»‘å®š
                document.removeEventListener("keydown", onKeyDown);
                document.addEventListener("keydown", onKeyDown);

                // ç»™iframeå†…éƒ¨ç»‘å®š
                if (!rendition) return;
                rendition.getContents().forEach((contents) => {
                    if (contents && contents.document) {
                        contents.document.removeEventListener(
                            "keydown",
                            onKeyDown
                        );
                        contents.document.addEventListener(
                            "keydown",
                            onKeyDown
                        );
                    }
                });

                // ç›‘å¬ä¹‹åï¼Œå¦‚æœåç»­renditionç¿»é¡µæˆ–ç« èŠ‚å˜äº†ï¼Œéœ€è¦é‡æ–°ç»‘å®šiframeå†…éƒ¨äº‹ä»¶
                rendition.on("rendered", () => {
                            console.log("EPUBå†…å®¹å·²æ¸²æŸ“ï¼Œåº”ç”¨è‡ªå®šä¹‰æ ·å¼å’Œäº‹ä»¶ç›‘å¬");
                            rendition.getContents().forEach((contents) => {
                                if (contents && contents.document) {
                                    // æ·»åŠ é”®ç›˜äº‹ä»¶ç›‘å¬
                                    contents.document.removeEventListener(
                                        "keydown",
                                        onKeyDown
                                    );
                                    contents.document.addEventListener(
                                        "keydown",
                                        onKeyDown
                                    );
                                    
                                    // è®¾ç½®æ ·å¼
                                    contents.document.documentElement.style.overflowX = "hidden";
                                    contents.document.body.style.overflowX = "hidden";
                                    
                                    // æ·»åŠ è‡ªå®šä¹‰æ ·å¼è¡¨
                                    const styleElement = contents.document.createElement('style');
                                    styleElement.textContent = `
                                        .highlight, .sentence.highlight {
                                            background-color: yellow !important;
                                            color: black !important;
                                        }
                                    `;
                                    contents.document.head.appendChild(styleElement);
                                    
                                    console.log("å·²å‘EPUBå†…å®¹æ·»åŠ è‡ªå®šä¹‰æ ·å¼è¡¨");
                                }
                            });
                            
                            const location = rendition.currentLocation();
                            if (location) {
                                rendition.emit("relocated", location);
                            }
                });
            }

            // é”®ç›˜ç¿»é¡µäº‹ä»¶
            function onKeyDown(e) {
                if (!state.isEpub || !rendition) return;
                if (e.key === "ArrowRight") {
                    e.preventDefault();
                    rendition.next();
                } else if (e.key === "ArrowLeft") {
                    e.preventDefault();
                    rendition.prev();
                } else if (e.key === "Space") {
                    // ç©ºæ ¼é”®æ§åˆ¶æœ—è¯»æš‚åœ/ç»§ç»­
                    e.preventDefault();
                    if (state.isSpeaking) {
                        if (mySpeechSynthesis.paused) {
                            resumeReading();
                        } else {
                            pauseReading();
                        }
                    } else {
                        startReading();
                    }
                }
            }

            function applyCurrentSettings() {
                // ç»Ÿä¸€å®šä¹‰èƒŒæ™¯è‰²å’Œæ–‡å­—è‰²æ˜ å°„
                const backgroundColorMap = {
                    dark: "#222",
                    sepia: "#f4ecd8",
                    light: "#fefefe",
                };
                const textColorMap = {
                    dark: "#eee",
                    sepia: "#5b4636",
                    light: "#333",
                };

                const bgColor = backgroundColorMap[state.theme] || "#fff";
                const txtColor = textColorMap[state.theme] || "#333";

                // è®¾ç½®æ•´ä¸ªé¡µé¢çš„èƒŒæ™¯è‰²å’Œæ–‡å­—é¢œè‰²
                document.body.style.backgroundColor = bgColor;
                document.body.style.color = txtColor;

                const container = document.querySelector(".container");
                if (container) {
                    container.style.backgroundColor = bgColor;
                    container.style.color = txtColor;
                }

                // æ ¹æ®å½“å‰é˜…è¯»æ¨¡å¼åˆ†åˆ«åº”ç”¨æ ·å¼
                if (state.isEpub && rendition && rendition.themes) {
                    applyEpubTheme();
                } else {
                    // çº¯æ–‡æœ¬é˜…è¯»åŒºåŸŸæ ·å¼
                    const content = reader.querySelector(".content");
                    if (content) {
                        content.style.fontSize = `${state.fontSize}px`;
                        content.style.lineHeight = state.lineHeight;
                        if (state.currentFont) {
                            content.style.fontFamily = `'${state.currentFont}', sans-serif`;
                        }
                    }
                    reader.style.backgroundColor = bgColor;
                    reader.style.color = txtColor;
                }
            }

            function applyEpubTheme() {
                if (!rendition || !rendition.themes) {
                    console.warn("rendition å°šæœªåˆå§‹åŒ–ï¼Œæ— æ³•åº”ç”¨ä¸»é¢˜");
                    return;
                }

                const style = {
                    body: {
                        "font-size": `${state.fontSize}px`,
                        "line-height": state.lineHeight,
                        background:
                            state.theme === "dark"
                                ? "#222"
                                : state.theme === "sepia"
                                ? "#f4ecd8"
                                : "white",
                        color:
                            state.theme === "dark"
                                ? "#eee"
                                : state.theme === "sepia"
                                ? "#5b4636"
                                : "#333",
                        "font-family": state.currentFont
                            ? `'${state.currentFont}', sans-serif`
                            : "inherit",
                    },
                };

                rendition.themes.register("custom", style);
                rendition.themes.select("custom");
                rendition.themes.override("html, body", {
                    "overflow-x": "hidden",
                    "box-sizing": "border-box",
                    "max-width": "100%",
                });

                rendition.themes.override("body", {
                    "overflow-x": "hidden",
                    "max-width": "100%",
                    "box-sizing": "border-box",
                });

                rendition.themes.override("img", {
                    "max-width": "100%",
                    height: "auto",
                });

                rendition.themes.override(".highlight", {
                    'background-color': 'yellow !important',
                    'color': 'black !important'
                });

                const backgroundColorMap = {
                    dark: "#222",
                    sepia: "#f4ecd8",
                    light: "#fefefe",
                };
                const textColorMap = {
                    dark: "#eee",
                    sepia: "#5b4636",
                    light: "#333",
                };

                const bgColor = backgroundColorMap[state.theme] || "#fff";
                const txtColor = textColorMap[state.theme] || "#333";

                // è®¾ç½®æ•´ä¸ªé¡µé¢çš„èƒŒæ™¯è‰²å’Œæ–‡å­—é¢œè‰²
                document.body.style.backgroundColor = bgColor;
                document.body.style.color = txtColor;

                const container = document.querySelector(".container");
                if (container) {
                    container.style.backgroundColor = bgColor;
                    container.style.color = txtColor;
                }
            }

            async function loadSystemFonts() {
                clearStatus();
                loadFontsBtn.disabled = true;
                loadFontsBtn.textContent = "åŠ è½½ä¸­...";
                try {
                    if (!("queryLocalFonts" in window))
                        throw new Error("æµè§ˆå™¨ä¸æ”¯æŒæœ¬åœ°å­—ä½“è®¿é—®");
                    const fonts = await window.queryLocalFonts();
                    const seen = new Set(),
                        fontList = [];
                    fonts.forEach((f) => {
                        const name = f.fullName || f.postscriptName;
                        if (name && !seen.has(name)) {
                            seen.add(name);
                            fontList.push({ name, value: f.postscriptName });
                        }
                    });
                    fontList.sort((a, b) => a.name.localeCompare(b.name));
                    fontSelector.innerHTML =
                        '<option value="">-- é€‰æ‹©å­—ä½“ --</option>';
                    fontList.forEach((f) => {
                        const opt = document.createElement("option");
                        opt.value = f.value;
                        opt.textContent = f.name;
                        fontSelector.appendChild(opt);
                    });
                    fontSelector.disabled = false;
                    showStatus(`å·²åŠ è½½ ${fontList.length} ç§å­—ä½“`, "success");
                } catch (e) {
                    console.error(e);
                    showStatus("å­—ä½“åŠ è½½å¤±è´¥ï¼Œå°†æä¾›é»˜è®¤å­—ä½“é€‰é¡¹", "error");
                    [
                        "Arial",
                        "Verdana",
                        "Times New Roman",
                        "Courier New",
                        "å®‹ä½“",
                        "å¾®è½¯é›…é»‘",
                    ].forEach((f) => {
                        const opt = document.createElement("option");
                        opt.value = f;
                        opt.textContent = f;
                        fontSelector.appendChild(opt);
                    });
                    fontSelector.disabled = false;
                } finally {
                    loadFontsBtn.disabled = false;
                    loadFontsBtn.textContent = "åŠ è½½ç³»ç»Ÿå­—ä½“";
                }
            }

            function applySelectedFont(e) {
                const font = e.target.value;
                if (!font) return;
                state.currentFont = font;

                const style = document.getElementById("customFontStyle");
                if (style) style.remove();

                const newStyle = document.createElement("style");
                newStyle.id = "customFontStyle";
                newStyle.textContent = `
                    @font-face { font-family: '${font}'; src: local('${font}'); }
                    #reader .content { font-family: '${font}', sans-serif; }
                `;
                document.head.appendChild(newStyle);

                currentFontDisplay.textContent = font;
                currentFontDisplay.style.fontFamily = `'${font}'`;

                applyCurrentSettings();
                showStatus(`å·²åº”ç”¨å­—ä½“: ${font}`, "success");
            }

            function updateFontSize() {
                state.fontSize = fontSizeSlider.value;
                fontSizeValue.textContent = `${state.fontSize}px`;
                applyCurrentSettings();
            }

            function updateLineHeight() {
                state.lineHeight = lineHeightSlider.value;
                lineHeightValue.textContent = state.lineHeight;
                applyCurrentSettings();
            }

            function updateTheme() {
                state.theme = themeSelect.value;
                applyCurrentSettings();
            }

            function applyCurrentSettings() {
                if (state.isEpub && rendition && rendition.themes) {
                    applyEpubTheme();
                } else {
                    // çº¯æ–‡æœ¬è°ƒæ•´æ ·å¼
                    const content = reader.querySelector(".content");
                    if (content) {
                        content.style.fontSize = `${state.fontSize}px`;
                        content.style.lineHeight = state.lineHeight;
                        if (state.currentFont) {
                            content.style.fontFamily = `'${state.currentFont}', sans-serif`;
                        }
                        switch (state.theme) {
                            case "dark":
                                reader.style.backgroundColor = "#222";
                                reader.style.color = "#eee";
                                break;
                            case "sepia":
                                reader.style.backgroundColor = "#f4ecd8";
                                reader.style.color = "#5b4636";
                                break;
                            default:
                                reader.style.backgroundColor = "white";
                                reader.style.color = "#333";
                        }
                    }
                }
            }

            function resetStyles() {
                state.currentFont = null;
                fontSelector.value = "";
                const oldStyle = document.getElementById("customFontStyle");
                if (oldStyle) oldStyle.remove();
                currentFontDisplay.textContent = "æœªé€‰æ‹©å­—ä½“";
                currentFontDisplay.style.fontFamily = "";
                state.fontSize = 16;
                state.lineHeight = 1.6;
                fontSizeSlider.value = 16;
                lineHeightSlider.value = 1.6;
                fontSizeValue.textContent = "16px";
                lineHeightValue.textContent = "1.6";
                state.theme = "light";
                themeSelect.value = "light";
                applyCurrentSettings();
                showStatus("å·²é‡ç½®æ‰€æœ‰æ ·å¼", "success");
            }

            function showStatus(msg, type) {
                statusDiv.textContent = msg;
                statusDiv.className = "status " + type;
            }

            function clearStatus() {
                statusDiv.textContent = "";
                statusDiv.className = "status";
            }
            
            // åˆå§‹åŒ–è¯­éŸ³åˆæˆ
            function initSpeechSynthesis() {
                if (!('speechSynthesis' in window)) {
                    showStatus("æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³åˆæˆåŠŸèƒ½", "error");
                    return;
                }
                
                // è·å–å¯ç”¨çš„è¯­éŸ³
                const voiceSelect = document.getElementById("voiceSelect");
                voiceSelect.innerHTML = "";
                
                // åŠ è½½è¯­éŸ³åˆ—è¡¨
                function loadVoices() {
                    const voices = mySpeechSynthesis.getVoices();
                    if (voices.length === 0) {
                        setTimeout(loadVoices, 100);
                        return;
                    }
                    
                    // æŒ‰è¯­è¨€æ’åº
                    voices.sort((a, b) => {
                        return a.lang.localeCompare(b.lang);
                    });
                    
                    // æ·»åŠ åˆ°ä¸‹æ‹‰åˆ—è¡¨
                    voices.forEach(voice => {
                        const option = document.createElement("option");
                        option.value = voice.name;
                        option.textContent = `${voice.name} (${voice.lang})`;
                        // é»˜è®¤é€‰æ‹©ä¸­æ–‡è¯­éŸ³
                        if (voice.lang.includes("zh") || voice.lang.includes("cmn")) {
                            option.selected = true;
                        }
                        voiceSelect.appendChild(option);
                    });
                }
                
                // Chromeéœ€è¦ç­‰å¾…voiceschangedäº‹ä»¶
                mySpeechSynthesis.addEventListener("voiceschanged", loadVoices);
                loadVoices(); // åˆå§‹åŠ è½½
            }
            
            // å°†æ–‡æœ¬åˆ†å‰²æˆå¥å­
            function splitTextIntoSentences(text) {
                console.log("åˆ†å‰²æ–‡æœ¬æˆå¥å­ï¼Œæ–‡æœ¬é•¿åº¦:", text.length);
                
                if (!text || text.trim().length === 0) {
                    console.error("æ–‡æœ¬ä¸ºç©ºï¼Œæ— æ³•åˆ†å‰²");
                    return ["æ— å¯æœ—è¯»å†…å®¹"];
                }
                
                try {
                    // ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼åˆ†å‰²å¥å­ï¼Œè€ƒè™‘ä¸­è‹±æ–‡æ ‡ç‚¹
                    const sentenceRegex = /([.!?ã€‚ï¼ï¼Ÿâ€¦]+\s*)/g;
                    const sentences = text.split(sentenceRegex).filter(s => s.trim().length > 0);
                    
                    console.log("åˆæ­¥åˆ†å‰²åçš„ç‰‡æ®µæ•°é‡:", sentences.length);
                    
                    // åˆå¹¶å¥å­å’Œæ ‡ç‚¹
                    const result = [];
                    for (let i = 0; i < sentences.length; i += 2) {
                        let sentence = sentences[i];
                        if (i + 1 < sentences.length) {
                            sentence += sentences[i + 1];
                        }
                        result.push(sentence);
                    }
                    
                    console.log("æœ€ç»ˆå¥å­æ•°é‡:", result.length);
                    
                    // å¦‚æœæ²¡æœ‰æˆåŠŸåˆ†å‰²ï¼Œåˆ™å°†æ•´ä¸ªæ–‡æœ¬ä½œä¸ºä¸€ä¸ªå¥å­
                    if (result.length === 0) {
                        console.warn("æœªèƒ½åˆ†å‰²å‡ºå¥å­ï¼Œå°†æ•´ä¸ªæ–‡æœ¬ä½œä¸ºä¸€ä¸ªå¥å­");
                        return [text];
                    }
                    
                    return result;
                } catch (error) {
                    console.error("åˆ†å‰²å¥å­æ—¶å‡ºé”™:", error);
                    return [text]; // å‡ºé”™æ—¶è¿”å›åŸæ–‡æœ¬ä½œä¸ºä¸€ä¸ªå¥å­
                }
            }
            
            // å¼€å§‹æœ—è¯»
            function startReading() {
                console.log("å¼€å§‹æœ—è¯»å‡½æ•°è¢«è°ƒç”¨");
                
                // æ£€æŸ¥è¯­éŸ³åˆæˆAPIæ˜¯å¦å¯ç”¨
                if (!('speechSynthesis' in window)) {
                    console.error("è¯­éŸ³åˆæˆAPIä¸å¯ç”¨");
                    showStatus("æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³åˆæˆåŠŸèƒ½", "error");
                    return;
                }
                
                if (state.isSpeaking) {
                    stopReading();
                } else {
                    // å¦‚æœä¸æ˜¯ä»æœ—è¯»çŠ¶æ€é‡æ–°å¼€å§‹ï¼Œåˆ™éœ€è¦æ‰‹åŠ¨æ¸…é™¤æ‰€æœ‰é«˜äº®
                    removeAllHighlights();
                }
                
                // è®¾ç½®æœ—è¯»çŠ¶æ€
                state.isSpeaking = true;
                currentSentenceIndex = 0;
                
                if (state.isEpub) {
                    console.log("å¼€å§‹æœ—è¯»EPUBå†…å®¹");
                    startEpubReading();
                } else {
                    console.log("å¼€å§‹æœ—è¯»çº¯æ–‡æœ¬å†…å®¹");
                    startTextReading();
                }
            }
            
            // æœ—è¯»çº¯æ–‡æœ¬å†…å®¹
            function startTextReading() {
                console.log("å¼€å§‹æœ—è¯»çº¯æ–‡æœ¬å†…å®¹å‡½æ•°è¢«è°ƒç”¨");
                console.log("å¥å­æ•°é‡:", sentences.length);
                
                if (sentences.length === 0) {
                    console.error("æ²¡æœ‰å¯æœ—è¯»çš„å¥å­");
                    showStatus("æ²¡æœ‰å¯æœ—è¯»çš„å†…å®¹", "error");
                    return;
                }
                
                state.isSpeaking = true;
                currentSentenceIndex = 0;
                console.log("å¼€å§‹æœ—è¯»ç¬¬ä¸€ä¸ªå¥å­");
                readCurrentSentence();
            }
            
            // æœ—è¯»EPUBå†…å®¹
            function startEpubReading() {
                console.log("å¼€å§‹æœ—è¯»EPUBå†…å®¹å‡½æ•°è¢«è°ƒç”¨");
                
                if (!rendition) {
                    console.error("EPUBæ¸²æŸ“å™¨æœªåˆå§‹åŒ–");
                    showStatus("EPUBæ¸²æŸ“å™¨æœªåˆå§‹åŒ–", "error");
                    return;
                }
                
                // è·å–å½“å‰é¡µé¢å†…å®¹
                const contents = rendition.getContents();
                if (!contents || contents.length === 0) {
                    console.error("æ— æ³•è·å–EPUBå†…å®¹");
                    showStatus("æ— æ³•è·å–EPUBå†…å®¹", "error");
                    return;
                }
                
                const doc = contents[0].document;
                if (!doc) {
                    console.error("æ— æ³•è·å–EPUBæ–‡æ¡£");
                    showStatus("æ— æ³•è·å–EPUBæ–‡æ¡£", "error");
                    return;
                }
                
                // è·å–å½“å‰é¡µé¢æ–‡æœ¬
                const text = doc.body.textContent;
                console.log("è·å–åˆ°EPUBæ–‡æœ¬é•¿åº¦:", text.length);
                currentChapterText = text;
                sentences = splitTextIntoSentences(text);
                console.log("EPUBå¥å­æ•°é‡:", sentences.length);
                currentSentenceIndex = 0;
                
                // ä¸ºå½“å‰é¡µé¢çš„æ–‡æœ¬èŠ‚ç‚¹æ·»åŠ æ ‡è®°ï¼Œä»¥ä¾¿é«˜äº®
                markTextNodesInEpub(doc);
                
                state.isSpeaking = true;
                console.log("å¼€å§‹æœ—è¯»EPUBç¬¬ä¸€ä¸ªå¥å­");
                readCurrentSentence();
            }
            
            // æ ‡è®°EPUBä¸­çš„æ–‡æœ¬èŠ‚ç‚¹
            function markTextNodesInEpub(doc) {
                // é€’å½’éå†æ‰€æœ‰æ–‡æœ¬èŠ‚ç‚¹
                function walkTextNodes(node, sentences, index) {
                    if (node.nodeType === 3 && node.textContent.trim().length > 0) {
                        // åˆ›å»ºä¸€ä¸ªspanå…ƒç´ åŒ…è£¹æ–‡æœ¬èŠ‚ç‚¹
                        const span = doc.createElement("span");
                        span.className = "sentence";
                        span.dataset.index = index;
                        // ç¡®ä¿spanå…ƒç´ å¯ä»¥è¢«æ­£ç¡®è¯†åˆ«å’Œæ ·å¼åŒ–
                        span.setAttribute("data-sentence", "true");
                        node.parentNode.replaceChild(span, node);
                        span.appendChild(node);
                        return index + 1;
                    } else if (node.nodeType === 1) {
                        // å…ƒç´ èŠ‚ç‚¹ï¼Œé€’å½’å¤„ç†å­èŠ‚ç‚¹
                        let currentIndex = index;
                        const childNodes = Array.from(node.childNodes);
                        for (const child of childNodes) {
                            currentIndex = walkTextNodes(child, sentences, currentIndex);
                        }
                        return currentIndex;
                    }
                    return index;
                }
                
                walkTextNodes(doc.body, sentences, 0);
            }
            
            // æœ—è¯»å½“å‰å¥å­
            function readCurrentSentence() {
                if (currentSentenceIndex >= sentences.length) {
                    // å½“å‰ç« èŠ‚æœ—è¯»å®Œæ¯•
                    if (state.autoNextChapter && state.isEpub) {
                        // è‡ªåŠ¨æœ—è¯»ä¸‹ä¸€ç« 
                        setTimeout(() => {
                            rendition.next().then(() => {
                                // ç­‰å¾…é¡µé¢åŠ è½½å®Œæˆ
                                setTimeout(() => {
                                    startEpubReading();
                                }, 500);
                            }).catch(() => {
                                // å·²ç»æ˜¯æœ€åä¸€ç« 
                                stopReading();
                                showStatus("æœ—è¯»å®Œæˆ", "success");
                            });
                        }, 1000);
                    } else {
                        stopReading();
                        showStatus("æœ—è¯»å®Œæˆ", "success");
                    }
                    return;
                }
                
                const sentence = sentences[currentSentenceIndex];
                state.currentSentence = sentence;
                
                // é«˜äº®å½“å‰å¥å­
                highlightCurrentSentence();
                
                // åˆ›å»ºè¯­éŸ³åˆæˆå®ä¾‹
                speechUtterance = new SpeechSynthesisUtterance(sentence);
                
                // è®¾ç½®è¯­éŸ³
                const voiceSelect = document.getElementById("voiceSelect");
                const voices = mySpeechSynthesis.getVoices();
                const selectedVoice = voices.find(voice => voice.name === voiceSelect.value);
                if (selectedVoice) {
                    speechUtterance.voice = selectedVoice;
                }
                
                // è®¾ç½®è¯­é€Ÿ
                const rateRange = document.getElementById("rateRange");
                speechUtterance.rate = parseFloat(rateRange.value);
                
                // å¥å­ç»“æŸäº‹ä»¶
                speechUtterance.onend = function() {
                    // ç§»é™¤å½“å‰å¥å­çš„é«˜äº®
                    if (state.isEpub) {
                        const contents = rendition.getContents();
                        if (contents && contents.length > 0) {
                            const doc = contents[0].document;
                            if (doc) {
                                const currentElements = doc.querySelectorAll(`.sentence[data-index="${currentSentenceIndex}"]`);
                                currentElements.forEach(el => {
                                    el.classList.remove("highlight");
                                    el.style.backgroundColor = "";
                                    el.style.color = "";
                                });
                            }
                        }
                    } else {
                        const currentElement = document.querySelector(`.sentence[data-index="${currentSentenceIndex}"]`);
                        if (currentElement) {
                            currentElement.classList.remove("highlight");
                            currentElement.style.backgroundColor = "";
                            currentElement.style.color = "";
                        }
                    }
                    
                    // ç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªå¥å­
                    currentSentenceIndex++;
                    readCurrentSentence();
                };
                
                // å¼€å§‹æœ—è¯»
                mySpeechSynthesis.speak(speechUtterance);
            }
            
            // é«˜äº®å½“å‰å¥å­
            function highlightCurrentSentence() {
                // ä¸å†ç§»é™¤æ‰€æœ‰é«˜äº®ï¼Œåªåœ¨å¥å­ç»“æŸæ—¶ç§»é™¤å½“å‰å¥å­çš„é«˜äº®
                // è¿™æ ·å¯ä»¥æé«˜æ•ˆç‡ï¼Œç‰¹åˆ«æ˜¯åœ¨æœ‰å¤§é‡å¥å­çš„æƒ…å†µä¸‹
                
                if (state.isEpub) {
                    // EPUBæ¨¡å¼ä¸‹é«˜äº®
                    const contents = rendition.getContents();
                    if (!contents || contents.length === 0) return;
                    
                    const doc = contents[0].document;
                    if (!doc) return;
                    
                    const sentenceElements = doc.querySelectorAll(`.sentence[data-index="${currentSentenceIndex}"]`);
                    console.log(`EPUBé«˜äº®: æ‰¾åˆ° ${sentenceElements.length} ä¸ªå¥å­å…ƒç´ `);
                    
                    sentenceElements.forEach(el => {
                        // æ·»åŠ ç±»å’Œå†…è”æ ·å¼åŒé‡ä¿éšœ
                        el.classList.add("highlight");
                        el.style.backgroundColor = "yellow";
                        el.style.color = "black";
                        // æ»šåŠ¨åˆ°å¯è§†åŒºåŸŸ
                        el.scrollIntoView({ behavior: "smooth", block: "center" });
                    });
                } else {
                    // çº¯æ–‡æœ¬æ¨¡å¼ä¸‹é«˜äº®
                    const sentenceElement = document.querySelector(`.sentence[data-index="${currentSentenceIndex}"]`);
                    if (sentenceElement) {
                        // æ·»åŠ ç±»å’Œå†…è”æ ·å¼åŒé‡ä¿éšœ
                        sentenceElement.classList.add("highlight");
                        sentenceElement.style.backgroundColor = "yellow";
                        sentenceElement.style.color = "black";
                        // æ»šåŠ¨åˆ°å¯è§†åŒºåŸŸ
                        sentenceElement.scrollIntoView({ behavior: "smooth", block: "center" });
                    }
                }
            }
            
            // æš‚åœæœ—è¯»
            function pauseReading() {
                if (state.isSpeaking) {
                    mySpeechSynthesis.pause();
                    showStatus("æœ—è¯»å·²æš‚åœ", "success");
                }
            }
            
            // ç»§ç»­æœ—è¯»
            function resumeReading() {
                if (state.isSpeaking && mySpeechSynthesis.paused) {
                    mySpeechSynthesis.resume();
                    showStatus("ç»§ç»­æœ—è¯»", "success");
                }
            }
            
            // åœæ­¢æœ—è¯»
            function stopReading() {
                mySpeechSynthesis.cancel();
                state.isSpeaking = false;
                state.currentSentence = null;
                
                // ç§»é™¤æ‰€æœ‰é«˜äº®
                removeAllHighlights();
                
                showStatus("æœ—è¯»å·²åœæ­¢", "success");
            }
            
            // ç§»é™¤æ‰€æœ‰é«˜äº®çš„è¾…åŠ©å‡½æ•°
            function removeAllHighlights() {
                // ç§»é™¤çº¯æ–‡æœ¬æ¨¡å¼ä¸‹çš„æ‰€æœ‰é«˜äº®
                const allSentences = document.querySelectorAll(".sentence");
                allSentences.forEach(el => {
                    el.classList.remove("highlight");
                    // ç§»é™¤å†…è”æ ·å¼
                    el.style.backgroundColor = "";
                    el.style.color = "";
                });
                
                // ç§»é™¤EPUBæ¨¡å¼ä¸‹çš„æ‰€æœ‰é«˜äº®
                if (state.isEpub && rendition) {
                    const contents = rendition.getContents();
                    if (contents && contents.length > 0) {
                        const doc = contents[0].document;
                        if (doc) {
                            const epubSentences = doc.querySelectorAll(".sentence");
                            epubSentences.forEach(el => {
                                el.classList.remove("highlight");
                                el.style.backgroundColor = "";
                                el.style.color = "";
                            });
                        }
                    }
                }
            }
            
            // æ›´æ–°è¯­é€Ÿ
            function updateSpeechRate() {
                const rateRange = document.getElementById("rateRange");
                const rate = parseFloat(rateRange.value);
                
                if (speechUtterance) {
                    speechUtterance.rate = rate;
                }
                
                // å¦‚æœæ­£åœ¨æœ—è¯»ï¼Œéœ€è¦é‡æ–°åº”ç”¨
                if (state.isSpeaking && !mySpeechSynthesis.paused) {
                    const currentIndex = currentSentenceIndex;
                    stopReading();
                    currentSentenceIndex = currentIndex;
                    state.isSpeaking = true;
                    readCurrentSentence();
                }
            }

            init();
        </script>
    </body>
</html>
